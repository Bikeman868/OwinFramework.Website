<h1>User Service</h1>

<p>
    This is a step-by-step walkthrough of creating a simple microservice using the Owin Framework.
</p>
<p>
    This walkthrough assumes that you have already completed the <a href="helloworld">Hello, World</a>
    walkthrough. If you have not completed it yet I suggest you at least read through these instructions 
    before continuing with this walkthrough.
</p>
<p>
    This walkthrough builds a microservice with these features:
</p>
<ul>
    <li>
        The microservice has an endpoint where you can POST a form to
        register a new user based on an email address and a password. Each user
        is allocated a unique ID.
    </li>
    <li>
        The microservice will not allow the same email address to be registered twice.
    </li>
    <li>
        The microservice has endpoints that you can POST a form to for logging in and
        logging out.
    </li>
    <li>
        The microservice has an endpoint that returns the user ID for the logged
        in user (based on session cookie) or empty string if the user is not logged
        in.
    </li>
    <li>
        The microservice has a very simple administration UI that shows a list of
        all of the registered users and whether they are currently logged in or not.
    </li>
</ul>

<p>
    To keep down the scope of this walkthrough and concentrate on the aspects of how
    to build a microservice and not how to build a database, this solution will only
    retain data in memory. All of the registered users will be wiped each time the
    service is restarted.
</p>

<h2>Overview</h2>

<p>
    The steps you will follow in this walktrhough are as follows:
</p>
<ol>
    <li>Create a new Visual Studio solution using the "ASP.Net Empty Web Site" project template</li>
    <li>Add the required Nuget packages to the solution</li>
    <li>Write a <span class="code">Startup.cs</span> and a <span class="code">Package.cs</span> file that configures all the libraries and wires everything up</li>
    <li>Define an interface to the data layer and create a test implementation that only saves data in memory</li>
    <li>Add a class that implements the user service endpoints</li>
    <li>Add a test page with forms for registration, login and log out just for testing</li>
    <li>Add an administration page that shows users and live updates when there are changes</li>
</ol>
<p>
    This walktrhough differs from writing a real microservice in these ways:
</p>
<ul>
    <li>
        The service would not normally implement the required business logic. This should be
        contained in a separate class and injected into the service implementation using IoC
    </li>
    <li>
        The data layer would need to persist the data to a persistent storage mechanism such
        as an RDBMS, NOSQL or Graph Database.
    </li>
    <li>
        All of the important classes should have unit tests. This is a much better approach than
        adding a test page because the tests are thorough, repeatable and can be automated.
    </li>
</ul>

<h2>Starting a new Visual Studio solution</h2>

<p>
    The most educational way of doing this walkthrough is by starting from a completely
    empty project and add all of the code. You don't need to actually type the code, copy/paste
    will work just fine.
</p>

<ol>
    <li>
        In Visual Studio start a new project of type "ASP.NET Empty Web Site".
        This will create a project that contains very little. In Visual Studio 2019
        the project template looks like this:
        <img class="app_diagram" src="/assets/images/walkthrough/microservice1/select-project-type.png">
    </li>
    <li>
        Install these NuGet packages
        <ul>
            <li><span class="code">Ioc.Modules.Ninject</span></li>
            <li><span class="code">Owin.Framework</span></li>
            <li><span class="code">Owin.Framework.Urchin</span></li>
            <li><span class="code">Owin.Framework.Pages.Core</span></li>
            <li><span class="code">Owin.Framework.Pages.Framework</span></li>
            <li><span class="code">Owin.Framework.Pages.Restful</span></li>
            <li><span class="code">Owin.Framework.Pages.Html</span></li>
            <li><span class="code">Microsoft.Owin.Host.SystemWeb</span></li>
        </ul>
    </li>
</ol>

<p>
    After installing, the Nuget Package Manager will look something like this 
    (version numbers will vary depending on which .Net Framework version you chose)
</p>
<img class="app_diagram" src="/assets/images/walkthrough/microservice1/nuget-packages.png">

<div class="app_hint">
    There are many other <a href="/content/index/nuget">Owin Framework NuGet packages</a> that
    are not illustrated by this walkthrough.
</div>

<h2>Configure your project as an OWIN website hosted on IIS</h2>

<p>
    Note that this step would be required for any OWIN application and is not
    specific to the Owin Framework.
</p>
<p>
    The steps required here are the same as for the <a href="helloworld">Hello, World</a>
    walkthrough. Please refer back to it for more details.
</p>

<h2>Configure an IoC container</h2>

<p>
    For this walkthrough we are going to use <a href="http://www.ninject.org/">Ninject</a> and <a href="https://github.com/Bikeman868/Urchin">Urchin</a>, but you can use any IoC container
    and any configuration mechanism you choose. There is <a href="/content/documentation/configuration/urchin">documentation</a> you can read and copy
    code from, or you can copy from <a href="https://github.com/Bikeman868/OwinFramework.Pages/blob/master/Sample2/Startup.cs">the hello world example</a>
</p>

<p>
    Read the documentation to figure out what code you need to add, or just copy the code
    below to get going quickly.
</p>

<pre>
var packageLocator = new PackageLocator()
   .ProbeBinFolderAssemblies()
   .Add(Assembly.GetExecutingAssembly());
var ninject = new StandardKernel(new Ioc.Modules.Ninject.Module(packageLocator));
</pre>

<h2>Set up the Owin Framework middleware pipeline</h2>

<p>
    This is the first step in this walktrhough that is specific to the Owin Framework
</p>

<p>
    You can review the <a href="/content/documentation/configuration/overview">documentation on Owin Framework configuration</a>, or you can look
    at <a href="https://github.com/Bikeman868/OwinFramework.Pages/blob/master/Sample2/Startup.cs"><span class="code">Startup.cs</span></a> 
    for a working example to copy from.
</p>

<p>
    An example of the type of code you will need to add to your <span class="code">Startup</span> 
    class is shown below for reference. In a real application there are a number of ways that you 
    can write this code. For this walkthrough you can copy/paste if you like.
</p>

<pre>
var config = ninject.Get&lt;IConfiguration>();

var pipelineBuilder = ninject.Get&lt;IBuilder>();
pipelineBuilder.Register(ninject.Get&lt;PagesMiddleware>()).ConfigureWith(config, "/pages");

app.UseBuilder(pipelineBuilder);
</pre>

<h2>Configure the Pages middleware</h2>

<p>
    In this section you will configure the Pages middleware to scan your compiled code
    and construct services and web pages from classes that are decorated with custom attributes.
</p>

<ol>
    <li>
        At the end of the <span class="code">Configuration</span> method in your <span class="code">Startup</span> class,
        resolve <span class="code">IFluentBuilder</span> from your IoC container, for example
        <pre>var fluentBuilder = ninject.Get&lt;IFluentBuilder>();</pre>
    </li>
    <li>
        Install the Restful service build engine so that we can define services by decorating classes
        with attributes. The code will be similar to this:
        <pre>ninject.Get&lt;OwinFramework.Pages.Restful.BuildEngine>().Install(fluentBuilder);</pre>
    </li>
    <li>
        Install the Html element build engine so that we can add web pages to our microservice by
        decorating classes with attributes. The required code is similar to this:
        <pre>ninject.Get&lt;OwinFramework.Pages.Html.BuildEngine>().Install(fluentBuilder);</pre>
    </li>
    <li>
        Get the fluent builder to scan your application assembly for classes that are
        decorated with attributes that makes them into definitions of serices, pages, regions,
        layouts etc. The fluent builder will use the build engines that we configured earlier.
        The extra line of code you need to add for this is:
        <pre>fluentBuilder.Register(Assembly.GetExecutingAssembly());</pre>
    </li>
    <li>
        Finally, after registering all of the elements of your website with the fluent
        builder you need to bind the elements together because they can reference each other
        by name, and they can be registered in any order. You will need this line of
        code to do this:
        <pre>ninject.Get&lt;INameManager>().Bind();</pre>
    </li>
</ol>

<div class="app_hint">
    If your microservice has no UI at all then you can skip the step of registering the html build 
    engine, and you can remove the reference to the <span class="code">Owin.Framework.Pages.Html</span> 
    Nuget package.
</div>
    
<div class="app_hint">
    Note that there are a number of Build Engines included in the base libraries, and you can
    also install third party Build Engines that provide alternate implementations. Build Engines 
    are like factories that contruct and configure Services, Pages, Layouts, Regions, Components, 
    Templates etc.
</div>

<p>
    At this point your <span>Startup.cs</span> file should look something like this:
    <pre>
using Ioc.Modules;
using Microsoft.Owin;
using Ninject;
using Owin;
using OwinFramework.Builder;
using OwinFramework.Interfaces.Builder;
using OwinFramework.Pages.Core;
using OwinFramework.Pages.Core.Interfaces.Builder;
using OwinFramework.Pages.Core.Interfaces.Managers;
using System.Reflection;

[assembly: OwinStartup(typeof(Startup))]

public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        var packageLocator = new PackageLocator()
            .ProbeBinFolderAssemblies()
            .Add(Assembly.GetExecutingAssembly());

        var ninject = new StandardKernel(new Ioc.Modules.Ninject.Module(packageLocator));

        var config = ninject.Get<IConfiguration>();

        var pipelineBuilder = ninject.Get<IBuilder>();
        pipelineBuilder.Register(ninject.Get<PagesMiddleware>()).ConfigureWith(config, "/pages");

        app.UseBuilder(pipelineBuilder);

        var fluentBuilder = ninject.Get<IFluentBuilder>();
        ninject.Get<OwinFramework.Pages.Restful.BuildEngine>().Install(fluentBuilder);
        ninject.Get<OwinFramework.Pages.Html.BuildEngine>().Install(fluentBuilder);

        fluentBuilder.Register(Assembly.GetExecutingAssembly());

        ninject.Get<INameManager>().Bind();
    }
}
    </pre>
</p>

<h2>Adding service endpoints</h2>

<p>
    There are many ways to add Restful service endpoints, but the easiest way is to add a class
    and decorate it with attributes, so lets do that. Go ahead and create a new class in the solution called
    <span class="code">HelloService.cs</span> containing the following code:
</p>
<pre>
    using OwinFramework.Pages.Core.Attributes;
    using OwinFramework.Pages.Core.Enums;
    using OwinFramework.Pages.Restful.Interfaces;
    
    [IsService("hello", Methods = new[] { Method.Get })]
    public class HelloService
    {
        [Endpoint(UrlPath = "/")]
        public void Hello(IEndpointRequest request)
        {
            request.Success("{message:'Hello, this is a microservice'}");
        }
    }
</pre>
<p>
    Now you can press F5 in Visual Studio and your microservice will handle the request and
    return a hello message.
</p>
<p>
    Wow, that was easy!
</p>
<p>
    All of your basic restful endpoints will be simple like this, but even the most complex
    scenarios are supported in a way that makes it as easy as possible to hide the complexity
    without sacrificing scaleability. See the <a href="/content/project/owinframework.pages.restful/landing">Restful builder documentation</a>
    for more information on how to take this up to the next level.
</p>

<div class="app_hint">
    <p>
        The only issue you are likely to encounter at this point is about version compatibility of
        Nuget packages. Most open source projects support a wide variety of frameworks and versions
        of .Net, but Microsoft's packages do not, and this leads to a situation where is can be quite 
        hard to find a combination of Nuget package versions that work together.
    </p>
    <p>
        The developers of the Owin Framework try to provide versions that are compatible with every
        version but Microsoft makes this very hard and there are many projects to update each time,
        so this is a far from ideal situation. We appologize if you experience Nuget version 
        incompatibilities at this point in the walkthrough.
    </p>
</div>

<h2>Building a dummy data layer</h2>

<p>
    In order to see a few more features and look at an example closer to the real world we are going
    to need a bit more code. Go ahead and add a data layer interface definition and an implementation
    of it from the source code below, then add a <span class="code">Package.cs</span> file so that
    IoC knows that this class is a singleton that implements the interface.
</p>
<p>
    To keep this example simple we can add all of this to one source file, but in your application
    you would break this up into one source file per type.
</p>

<h3>DataLayer.cs</h3>
<pre>
using Ioc.Modules;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;

public enum RegisterResult
{
    Registered,
    PasswordTooSimple,
    DuplicateEmail,
    InvalidEmail
}

public class User
{
    [JsonProperty]
    public string Email { get; set; }

    [JsonIgnore]
    public string Password { get; set; }

    [JsonProperty]
    public string LoginToken { get; set; }
}

public interface IDataLayer
{
    RegisterResult Register(string email, string password);
    string Login(string email, string password);
    void Logout(string loginToken);
    User[] GetUsers();
}

[Package]
public class DataLayerPackage : IPackage
{
    public string Name => "Data layer";

    public IList<IocRegistration> IocRegistrations => new List<IocRegistration>
    {
        new IocRegistration().Init<IDataLayer, DataLayer>()
    };
}

public class DataLayer: IDataLayer
{
    private readonly object _lock = new object();
    private User[] _users = new User[0];

    public User[] GetUsers()
    {
        return _users;
    }

    public RegisterResult Register(string email, string password)
    {
        if (string.IsNullOrWhiteSpace(email) || email.Count(c => c == '@') != 1)
            return RegisterResult.InvalidEmail;

        if (string.IsNullOrWhiteSpace(password) || password.Length < 5)
            return RegisterResult.PasswordTooSimple;

        lock(_lock)
        {
            if (_users.FirstOrDefault(u => string.Equals(u.Email, email, StringComparison.OrdinalIgnoreCase)) != null)
                return RegisterResult.DuplicateEmail;

            var newUser = new User
            {
                Email = email,
                Password = password,
                LoginToken = Guid.NewGuid().ToString("n")
            };
            var users = _users.ToList();
            users.Add(newUser);
            _users = users.ToArray();
        }

        return RegisterResult.Registered;
    }

    public string Login(string email, string password)
    {
        var user = _users.FirstOrDefault(u => 
            string.Equals(u.Email, email, StringComparison.OrdinalIgnoreCase) &&
            u.Password == password);

        if (user == null) return string.Empty;

        if (user.LoginToken == null)
            user.LoginToken = Guid.NewGuid().ToString("n");

        return user.LoginToken;
    }

    public void Logout(string loginToken)
    {
        var user = _users.FirstOrDefault(u => u.LoginToken == loginToken);

        if (user != null)
            user.LoginToken = null;
    }
}
</pre>

<h2>Adding the user service endpoints</h2>

<p>
    We did this already for the hello service example. Lets repeat that again with
    the injected dependency on the data layer we just created. Because we now have
    an injected dependency, we will also have to provide our Niject container to
    the fluent builder so that it can build our service.
</p>
<p>
    In your <span class="code">Startup.cs</span> file, modify the line of code that
    registers our executing assembly with the fluent builder to get it to use Ninject
    to build our service. The modified line of code looks like this:
</p>
<pre>fluentBuilder.Register(Assembly.GetExecutingAssembly(), t => ninject.Get(t));</pre>
<p>
    Now we can go ahead and add the service endpoints.
</p>

<h3>UserServiceEndpoints.cs</h3>
<pre>
using OwinFramework.Pages.Core.Attributes;
using OwinFramework.Pages.Core.Enums;
using OwinFramework.Pages.Restful.Interfaces;
using OwinFramework.Pages.Restful.Parameters;

[IsService("user", BasePath = "/auth/", Methods = new[] { Method.Get, Method.Post })]
public class UserServiceEndpoints
{
    private readonly IDataLayer _dataLayer;

    public UserServiceEndpoints(IDataLayer dataLayer)
    {
        _dataLayer = dataLayer;
    }

    [Endpoint(Methods = new[] { Method.Get })]
    public void Users(IEndpointRequest request)
    {
        request.Success(_dataLayer.GetUsers());
    }

    [Endpoint(Methods = new[] { Method.Post })]
    [EndpointParameter("email", typeof(RequiredString), EndpointParameterType.FormField)]
    [EndpointParameter("password", typeof(RequiredString), EndpointParameterType.FormField)]
    public void Register(IEndpointRequest request)
    {
        var email = request.Parameter<string>("email");
        var password = request.Parameter<string>("password");

        request.Success(_dataLayer.Register(email, password));
    }

    [Endpoint(Methods = new[] { Method.Post })]
    [EndpointParameter("email", typeof(RequiredString), EndpointParameterType.FormField)]
    [EndpointParameter("password", typeof(RequiredString), EndpointParameterType.FormField)]
    public void Login(IEndpointRequest request)
    {
        var email = request.Parameter<string>("email");
        var password = request.Parameter<string>("password");

        request.Success(_dataLayer.Login(email, password));
    }

    [Endpoint(Methods = new[] { Method.Post })]
    [EndpointParameter("token", typeof(RequiredString), EndpointParameterType.QueryString)]
    public void Logout(IEndpointRequest request)
    {
        var token = request.Parameter<string>("token");
        _dataLayer.Logout(token);
        request.Success();
    }
}    
</pre>

<p>
    At this point we have a fully functional microservice and you can test it using a tool
    like PostMan. Even though it is complete we will be adding more to it below to achieve
    the specification we were looking for.  First of all lets explain this source file in
    detail.
</p>

<p>
    The <span class="code">Users()</span> method can be called with a GET request to the 
    url <span class="code">/auth/users</span>. This endpoint just calls the data layer and
    serializes the list of users to JSON. You can press F5 in Visual Studio and append 
    <span class="code">/auth/users</span> to the url and your service should return an empty 
    array of users.
</p>

<div class="app_hint">
    If you don't specify the url path for an endpoint it defaults to a concatenation of 
    the <span class="code">BasePath</span> property of the <span class="code">IsService</span> 
    attribute and the name of the endpoint method. If you do specify the url path of the 
    endpoint you can either make it relative to the base path of the service by not starting
    with a leading forward slash, or absoulte within the website (as we did in the hello 
    service example) by putting forward slash as the first character of the path.
</div>

<div class="app_hint">
    You can serialize the response to other formats as well as JSON by explicitly specifying
    the serializer to use. When no serializer is specified JSON is the default. You can also
    specify the serializer on the service itself and optionally override this for each
    endpoint.
</div>

<p>
    The <span class="code">Register()</span> method must be called using a POST request, and
    takes two parameters. The <span class="code">EndpointParameter</span> 
    attributes define that these are form fields and that they must be non-empty strings.
    If you call this endpoint with invalid parameters then the Owin Framework will return a
    400 response status with a validation message.
</p>
<p>
    To read the parameters that were passed in, the <span class="code">Users()</span> method
    calls the <span class="code">Parameter()</span> method of the request passing the name
    of the parameter. The Owin Framework will parse the body of the POST as a form and
    extract the form field values, validate them and return the value to the appllication.
</p>

<div class="app_warning">
    It is very important when retrieving endpoint parameters that the type specified in the
    call to the <span class="code">Parameter()</span> method matches the type of data returned
    by the parameter validator. In this example we passed the <span class="code">typeof(RequiredString)</span> 
    as the parameter validator so we must retrieve the parameter value as <span class="code">string</span>.
</div>
    
<h2>Adding some forms to test it</h2>

<p>
    To fully test this we need to be able to POST some forms, and since some microservices have
    a user interface, we are going to go ahead and see an example of how we might easily add
    a user interface to our microservice. Note that this step is completely optional since
    many microservices do not have any UI. If you are using this tutorial as a stating point
    for your own microservice and you don't have any UI then I recommend removing the dependency
    on the <span class="code">Owin.Framework.Pages.Html</span> Nuget package from your project.
</p>
<p>
    In this case we can add some simple forms by adding an html file to our project and 
    serving this as a static asset. We could do this with a service endpoint, but the
    Owin Framework Static Files middleware will do it much better.
</p>
<p>
    To be completed ...
</p>

<h2>Adding a management UI</h2>

<p>
    There are many choices available for creating a UI. The Pages part of the Owin Framework is
    designed to provide complete flexibility to cater to all the different kinds of website and
    web services that exist from a simple UI on a microservice to a website with millions of pages
    being served to billions of users. For the purpose of this walkthrough I have decided to show
    how to build pages where each page in a <span class="code">Vue.js</span> view model defined 
    by a JavaScript file and an html file, but this is by no means the only way to do this.
</p>
<p>
    To be completed ...
</p>